Technical Migration Architecture: Re-engineering Legacy Single-Page Applications to Hypermedia-Driven Python Systems


1. Executive Summary and Architectural Paradigm Shift

The contemporary web development landscape is currently undergoing a significant correction, often referred to as the "hypermedia return." For years, the industry standard for web application development has gravitated heavily toward the Single Page Application (SPA) model, utilizing frameworks such as Next.js, React, and Vue. While these frameworks offer powerful capabilities for complex state management on the client side, they introduce substantial overhead, complexity, and fragility—manifesting in the "hydration errors" and stability issues reported in the user's current Next.js deployment. This report outlines a comprehensive architectural strategy to migrate a destabilized Next.js application to a robust, server-side rendered (SSR) Python environment utilizing Flask, Firebase Realtime Database, and HTMX.
The proposed architecture represents a fundamental shift in philosophy. Rather than treating the web browser as a runtime environment for a thick client application (which fetches JSON and renders HTML locally), the new architecture treats the browser as a hypermedia client. In this model, the Python server acts as the source of truth, generating HTML states that are swapped into the Document Object Model (DOM) dynamically. This approach, facilitated by HTMX, reduces the JavaScript payload by orders of magnitude, eliminates synchronization bugs between client and server state, and leverages the stability of Python’s backend processing capabilities.1
Furthermore, the requirement to integrate a Masonry grid layout—a layout notoriously difficult to manage with pure CSS due to the complexities of vertical space packing—introduces specific challenges when combined with dynamic content loading. This report provides a mathematically grounded approach to bridging the gap between server-side HTML injection and client-side geometry calculations using Masonry.js and HTMX event listeners.3 Additionally, the migration strategy addresses the ingestion of legacy data through a custom-built ENEX (Evernote Export) parsing engine, ensuring that the application can handle large-scale data imports without overwhelming server memory.5

1.1 The Analysis of Failure in the Next.js Model

The user's previous experience with Next.js instability is symptomatic of a broader class of problems inherent to the "Thick Client" architecture. In a Next.js application, the server performs an initial render of the page (SSR) and sends the HTML to the client. Subsequently, a large JavaScript bundle is downloaded to "hydrate" that HTML, attaching event listeners and rebuilding the application state in the browser's memory.
Instability often arises from the "uncanny valley" of hydration: if the HTML rendered by the server differs even slightly from the HTML the client-side JavaScript expects to generate (due to browser extensions, malformed HTML in the database, or non-deterministic data sorting), the framework throws hydration errors, causing the UI to flash, break, or become unresponsive. By migrating to Flask, we eliminate the hydration step entirely. The HTML sent by the server is the final representation. Interactivity is handled not by rebuilding the DOM, but by swapping specific fragments of it upon user interaction.

1.2 The Hypermedia Advantage

The architectural pivot to a Flask/HTMX stack simplifies the mental model of the application. State management, arguably the most difficult aspect of frontend development, is retreated entirely to the database. There are no client-side stores (like Redux or Recoil) to synchronize. The database is the single source of truth. When a user requests to "load more" items for the Masonry grid, the client does not request JSON data to interpret; it requests the visual representation (the HTML cards) of that data.
This report details the implementation of this architecture across four primary domains:
Server-Side Foundation: Flask Application Factory, Blueprints, and Configuration.
Persistence Layer: Firebase Realtime Database, NoSQL data modeling, and Cursor-based Pagination.
Ingestion Engine: Streaming XML parsing for ENEX files and content sanitization.
Presentation & Interactivity: Jinja2 templating, HTMX lifecycle management, and Masonry Grid integration.

2. Server-Side Application Architecture: The Flask Ecosystem

Flask is categorized as a micro-framework, meaning it does not enforce a specific project structure or set of dependencies (unlike Django). While this offers flexibility, it places the burden of architectural discipline on the developer. To support a production-grade application capable of handling complex data ingestion and dynamic frontend rendering, a flat file structure is insufficient. We must adopt the "Application Factory" pattern and a modular Blueprint system.

2.1 The Application Factory Pattern

The Application Factory pattern involves wrapping the creation of the Flask object inside a Python function. This is critical for testing and separation of concerns. It allows multiple instances of the application to exist with different configurations (e.g., a testing instance connecting to a mock database and a production instance connecting to the live Firebase instance).7
The recommended directory structure for this migration is as follows:
/project_root
/app
init.py # Contains the create_app() factory
/blueprints
/main
init.py
routes.py # Handles standard page loads (GET /)
/api
init.py
routes.py # Handles HTMX fragments (GET /load-more)
/ingest
init.py
routes.py # Handles ENEX file uploads
/services
firebase_service.py # Wrapper for Firebase Admin SDK
parser_service.py # Logic for ENEX parsing and sanitization
/templates
base.html # The skeleton (Head, Scripts, Navbar)
index.html # The main view
/components
card.html # Jinja macro for the grid item
/partials
grid.html # The dynamic container for HTMX swaps
/static
/css
masonry.css
/js
app.js # Masonry initialization & HTMX event listeners
config.py # Environment variable management
run.py # WSGI Entry point
requirements.txt
This structure adheres to the separation of concerns principle. The blueprints directory separates the visual logic (View Routes) from the functional logic (API/Ingestion Routes). The services directory isolates the business logic (database interaction, file parsing) from the HTTP layer.

2.2 Configuration and Security

Secure management of credentials is paramount, particularly when interacting with Firebase. The Next.js application likely used the Firebase Client SDK, which relies on API keys embedded in the frontend code and Security Rules configured in the Firebase Console. The Python Admin SDK, however, operates with administrative privileges. It bypasses Firebase Security Rules entirely. Therefore, the Service Account credentials must never be exposed or committed to version control.8
The config.py module should utilize python-dotenv to load sensitive data.

Python


# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-key-fallback'
    FIREBASE_CREDENTIALS_PATH = os.environ.get('FIREBASE_CREDENTIALS_PATH')
    FIREBASE_DB_URL = os.environ.get('FIREBASE_DB_URL')
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # Limit uploads to 16MB


In the create_app function, these configurations are loaded into the Flask app context. This centralization allows for easy modification of system behaviors (like upload limits or database URLs) without altering the codebase.7

2.3 Dependency Injection and Service Instantiation

To maintain a clean global state, the Firebase Admin SDK should be initialized once. The firebase_admin.initialize_app() function ensures a connection pool is established. Repeatedly calling this function will raise an exception. The initialization logic belongs in app/__init__.py, outside the blueprint definitions but inside the factory or as a global protected by a check for firebase_admin._apps.8

3. Persistence Layer Engineering: Firebase Realtime Database

The User Query specifies a strict requirement to retain Firebase as the data source. Moving from a client-side usage of Firebase (in Next.js) to a server-side usage (in Python) fundamentally changes how data is accessed and structured. The Firebase Realtime Database is a NoSQL, cloud-hosted JSON tree. It does not possess tables, rows, or columns. It has keys and values. This distinction drives every decision in the data modeling process.10

3.1 Data Structure and Key Limitations

Efficient querying in Firebase requires a flat data structure. In a relational database, one might normalize data into Users, Posts, and Comments tables. In the JSON tree, deep nesting is the enemy of performance. If the application stores posts inside the user object (e.g., /users/uid/posts), fetching the user profile to display a name inevitably downloads their entire post history.
The report recommends the following flattened schema to support the Masonry grid application:
Table 1: Proposed JSON Data Schema
Path
Structure Description
Purpose
/posts
{ "post_id": { "title": "...", "content": "...", "timestamp": 12345, "author_id": "uid" } }
Main data repository. Flat list for efficient querying.
/users
{ "uid": { "displayName": "...", "email": "..." } }
User profiles, kept separate to minimize payload size.
/user-posts
{ "uid": { "post_id": true, "post_id_2": true } }
Index mapping users to their posts (Fan-out on write).

Key Constraints:
When implementing the Ingestion Engine (discussed in Chapter 4), we must be cognizant of Firebase's key limitations. Keys must be UTF-8 encoded, cannot exceed 768 bytes, and cannot contain ., $, #, [, ], /, or ASCII control characters 0-31 or 127.10 This is critical when parsing ENEX files, as using a note's title as a key would likely violate these rules. Therefore, the application must generate unique IDs (using push() or UUIDs) rather than relying on natural keys.

3.2 Blocking I/O vs. Asynchronous Events

In the Next.js environment, the Firebase Client SDK utilizes WebSockets to maintain an open connection, allowing for real-time event listeners (on('value', callback)). The Python Admin SDK, however, primarily operates via blocking HTTP REST calls. When the Flask application executes ref.get(), the thread blocks until the data is downloaded from Google's servers.11
This has two major implications:
Latency: Every database read adds to the Time To First Byte (TTFB). Queries must be highly optimized to fetch only the necessary data.
Concurrency: Flask's development server is single-threaded by default. In production, a WSGI server like Gunicorn with gevent or multiple workers is required to handle concurrent requests without the database blocking the entire application.

3.3 Advanced Cursor-Based Pagination

Pagination is the single most complex aspect of this migration. The user intends to use a Masonry layout, which typically implies an "Infinite Scroll" UI pattern. Implementing this efficiently in a NoSQL JSON tree requires "Cursor-based Pagination."
Standard SQL pagination uses OFFSET (e.g., LIMIT 10 OFFSET 50). This instructs the database to read 60 items and discard the first 50. In a large JSON tree, this is performatively disastrous. Firebase does not support OFFSET. Instead, we must tell Firebase specifically where to start reading.12
The Algorithm:
Initial Load: The application requests the most recent $N$ items.
Query: ref.order_by_child('timestamp').limit_to_last(20)
Cursor Extraction: The application identifies the timestamp of the last item in the retrieved list (which is chronologically the oldest, since limit_to_last returns items from the end of the timeline). This timestamp becomes the cursor.
Subsequent Loads (HTMX): When the user triggers "Load More," the cursor is sent to the server. The server requests items ending at that cursor.
Query: ref.order_by_child('timestamp').end_at(cursor).limit_to_last(21)
The Overlap Problem:
The end_at() method in Firebase is inclusive. If we request items ending at timestamp X, the item with timestamp X will be included in the result. Therefore, we must request Limit + 1 items. The first item in the returned result (which corresponds to the cursor from the previous page) must be discarded in the Python logic to prevent duplicate posts from appearing in the grid.13
Table 2: Pagination Query Logic
Step
Firebase Method
Parameter
Reasoning
Ordering
order_by_child('timestamp')
N/A
Establishes the chronological sort order required for a feed.
Filtering
end_at(cursor_value)
last_timestamp
Restricts the query to items older than or equal to the cursor.
Limiting
limit_to_last(N + 1)
PageSize + 1
Fetches the page plus the overlapping cursor item.
Clean Up
Python List Slicing
results[:-1]
Removes the cursor item (which was displayed on the previous page).


4. The Ingestion Engine: Processing ENEX and XML

The requirement to "inspect the repo" and the nature of Masonry layouts (often used for note-taking or image collecting) strongly suggests the migration of data from services like Evernote or similar XML-based formats. The research snippets confirm that handling .enex files is a likely requirement. Parsing these files is not trivial due to memory constraints and the specific XML structure used by Evernote.5

4.1 Streaming XML Parsing with iterparse

An ENEX export file can be massive, containing thousands of notes and embedded base64 images, potentially reaching gigabytes in size. Loading this entire Document Object Model (DOM) into memory using a standard XML parser (like minidom or BeautifulSoup's default parser) will cause the Flask worker to exceed its memory allocation and crash (OOM Kill).
The solution is streaming parsing using Python’s xml.etree.ElementTree.iterparse. This method allows the application to traverse the XML file event-by-event. We listen for the end event of the note tag. Once a note is fully parsed, processed, and uploaded to Firebase, we explicitly call elem.clear() to remove it from memory. This ensures that the memory footprint remains constant regardless of the file size.5
Implementation Logic:

Python


import xml.etree.ElementTree as ET

def parse_stream(file_stream):
    # iterparse provides an iterator of (event, elem) pairs
    context = ET.iterparse(file_stream, events=("end",))
    
    for event, elem in context:
        if elem.tag == 'note':
            process_note(elem)
            elem.clear()  # Crucial: Discards the element from RAM
            
def process_note(note_elem):
    title = note_elem.find('title').text
    content = note_elem.find('content').text
    #... extraction logic...



4.2 Content Sanitization and ENML

The content inside an ENEX file is stored as CDATA and formatted in ENML (Evernote Markup Language), which is a superset of HTML. However, it contains specific tags like <en-note> and <en-media> that browsers do not understand. Before pushing this data to Firebase for rendering in the Flask app, it must be sanitized and transformed.
Sanitization Strategy:
Strip Proprietary Tags: The <en-note> wrapper must be removed, leaving the inner HTML.
Resource Handling: The <en-media> tag represents an attachment (usually an image). It contains a hash attribute. The parser must locate the corresponding <resource> element in the XML, which contains the base64 encoded data of the image.
Decoding and Storage: Storing base64 strings in Firebase Realtime Database is an anti-pattern (it bloats the JSON tree and slows down parsing). The ParserService should decode the base64 string, upload the binary data to a dedicated file store (like Firebase Storage or AWS S3), obtain a public URL, and replace the <en-media> tag with a standard HTML <img src="URL"> tag.16
XSS Prevention: Since we will be rendering this HTML using the | safe filter in Jinja2 (to prevent escaping), we must ensure no malicious scripts exist in the import. A library like bleach should be used to whitelist only safe tags (div, span, b, i, img) and strip script, iframe, and object tags.17

5. Frontend Orchestration: Jinja2, HTMX, and Masonry

This section details the convergence of the server-side architecture with the client-side presentation. This is the "View" layer that replaces the Next.js React components.

5.1 Jinja2 Component Architecture

To replicate the reusability of React components, we utilize Jinja2 Macros. Macros allow us to define a snippet of HTML (like a card in the Masonry grid) once and reuse it in multiple contexts—both for the initial page render and for the dynamic HTMX updates.18
The Card Macro (templates/components/card.html):

HTML


{% macro render_card(post) %}
<div class="grid-item">
    <div class="card-content">
        <h3 class="card-title">{{ post.title }}</h3>
        <div class="card-body">
            {# The safe filter is mandatory for rendering HTML content #}
            {{ post.content | safe }}
        </div>
        <div class="card-meta">
            {{ post.timestamp | datetime_format }}
        </div>
    </div>
</div>
{% endmacro %}


Using the | safe filter is a calculated risk. It tells Jinja "trust this variable, it is valid HTML, do not escape the brackets." This reinforces the necessity of the strict sanitization described in Chapter 4. If unsanitized data enters the database, the application becomes vulnerable to Stored Cross-Site Scripting (XSS) attacks.17

5.2 HTMX Lifecycle and "Load More"

HTMX allows us to add interactivity using HTML attributes. For the "Load More" functionality, we avoid writing custom fetch() calls. Instead, we place a trigger element at the bottom of the grid.
Attributes Breakdown:
hx-get="/api/load-more?cursor={{ last_cursor }}": Defines the endpoint and passes the pagination cursor.
hx-trigger="click": Defines the event. This could also be revealed to implement infinite scroll.
hx-target="#grid-container": Tells HTMX where to put the response.
hx-swap="beforeend": Crucial. By default, HTMX replaces the target's content. beforeend appends the new content inside the target, after the last child. This preserves the existing items in the grid.1

5.3 The Masonry Integration Challenge

Integrating Masonry.js with any dynamic content loader (React, Vue, or HTMX) presents a geometry problem. Masonry calculates the absolute position (top, left) of each grid item based on the height of the items around it. It performs this calculation when initialized.
When HTMX injects new HTML elements into the DOM via hx-swap, Masonry is unaware of their existence. The new elements will simply stack vertically or overlap existing items, destroying the layout.20
The Solution: The htmx:afterSwap Bridge
To fix this, we must intercept the HTMX event lifecycle. HTMX emits a series of events. The most relevant for layout recalculation is htmx:afterSwap, which fires after the new content has been inserted into the DOM but before the browser has finished painting.22
We must implement a JavaScript bridge in static/js/app.js:

JavaScript


// 1. Initialize Masonry on the grid container
var grid = document.querySelector('.grid');
var msnry = new Masonry( grid, {
  itemSelector: '.grid-item',
  columnWidth: '.grid-sizer',
  percentPosition: true
});

// 2. Listen for HTMX swaps
document.body.addEventListener('htmx:afterSwap', function(evt) {
    // 3. Filter: Only act if the swap occurred in our grid
    if (evt.detail.target.id === 'grid-container') {
        
        // 4. Reload Items: Tell Masonry to scan the DOM for new elements
        msnry.reloadItems();
        
        // 5. Layout: Tell Masonry to recalculate positions
        msnry.layout();
    }
});


Refined Optimization:
While reloadItems() works, it forces Masonry to re-process every item in the grid. As the user scrolls and the grid grows to thousands of items, this becomes slow. A more performant approach is to identify only the new elements. The evt.detail.elt property in the HTMX event contains the swapped content. We can pass these specific nodes to Masonry's appended() method.

JavaScript


// Optimized Bridge
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.target.id === 'grid-container') {
        // evt.detail.elt contains the response fragment
        // We need to select the grid items from within that fragment
        // Note: This depends on whether the response is a list of items or a container
        var newItems = evt.detail.elt.querySelectorAll('.grid-item');
        msnry.appended(newItems);
    }
});


This requires that the server response (the partial) is structured correctly to allow query selection of the new items.4
Image Loading Latency:
A secondary issue is images. If the new cards contain images, Masonry might calculate the layout before the images have fully loaded (when their height is 0). This causes items to overlap once the images pop in. To resolve this, we must use the imagesLoaded library in conjunction with Masonry. The standard pattern is imagesLoaded( grid, function() { msnry.layout(); });. Inside the HTMX listener, we should wrap the layout call in imagesLoaded to ensure the geometry is calculated against the final rendered heights.3

6. Implementation Strategy: Step-by-Step Code Construction

This chapter synthesizes the architectural decisions into a cohesive implementation plan.

6.1 Step 1: The Base Templates

We begin by defining base.html. This file acts as the single source of truth for loading external libraries. We include HTMX (via CDN or local static file), Masonry.js, and imagesLoaded.pkgd.js.

HTML


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Masonry Python Archive</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        {% block content %}{% endblock %}
    </div>

    <script src="https://unpkg.com/htmx.org@1.9.0"></script>
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
    <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
    <script src="{{ url_for('static', filename='js/app.js') }}"></script>
</body>
</html>



6.2 Step 2: The View Route (main)

The main route in app/blueprints/main/routes.py handles the initial GET request. It calls the FirebaseService to fetch the first page of posts.

Python


from flask import render_template, current_app
from app.blueprints.main import main_bp
from app.services.firebase_service import get_paginated_posts

@main_bp.route('/')
def index():
    # Initial load: Fetch 20 posts
    posts, next_cursor = get_paginated_posts(limit=20)
    return render_template('index.html', posts=posts, next_cursor=next_cursor)



6.3 Step 3: The API Route (api)

The API route in app/blueprints/api/routes.py is designed for HTMX. Crucially, it does not return a JSON object. It returns HTML.

Python


from flask import request, render_template
from app.blueprints.api import api_bp
from app.services.firebase_service import get_paginated_posts

@api_bp.route('/load-more')
def load_more():
    cursor = request.args.get('cursor')
    # Fetch next 20 posts starting after the cursor
    posts, next_cursor = get_paginated_posts(limit=20, end_at=cursor)
    
    # Return ONLY the grid items, not the full page
    return render_template('partials/grid_items.html', posts=posts, next_cursor=next_cursor)


Note the template distinction: partials/grid_items.html iterates through the posts and renders the card macros. It must also include the new trigger element at the bottom (with the new cursor) so the cycle can continue. This is a recursive UI pattern known as "Recursive Replacement" in HTMX.

7. Performance and Optimization

While the Python/HTMX stack is generally more performant for the client than a heavy SPA, specific bottlenecks must be addressed.

7.1 Caching Strategy

Firebase Realtime Database charges based on "GB Downloaded." Repeatedly fetching the same posts for every user hits the quota and increases latency. Implementing a caching layer is essential.
Flask-Caching:
We can utilize Flask-Caching with a Redis or SimpleCache backend. The index route can be cached for a short duration (e.g., 60 seconds).

Python


@main_bp.route('/')
@cache.cached(timeout=60)
def index():
   ...


However, caching the cursor-based API routes is trickier because the cursor varies. A better strategy is to cache the individual post data at the service level (memoization) rather than the entire HTML response, or cache the HTML fragments based on the cursor key.18

7.2 Bandwidth Optimization

Although HTMX saves the overhead of the JavaScript framework, it still transmits HTML, which is more verbose than JSON.
Gzip/Brotli Compression: Flask must be configured to compress responses. If running behind Nginx, compression should be enabled at the proxy level.
Image Optimization: The parser service should ideally resize images during ingestion. Displaying a 4000px wide image in a 300px wide card is a massive waste of bandwidth and rendering time. Using a service like Cloudinary or Firebase Extensions ("Resize Images") to generate thumbnails is recommended.

8. Conclusion

The transition from Next.js to a Python Flask architecture utilizing Firebase and HTMX offers a decisive resolution to the stability and complexity issues plaguing the current application. By abandoning the "Thick Client" model in favor of a hypermedia-driven approach, we align the application's architecture with the fundamental strengths of the web: simple, declarative HTML state.
This report has outlined the critical path for this migration:
Adopting the Application Factory Pattern ensures the Flask backend is scalable and testable.
Implementing Cursor-Based Pagination overcomes the inherent limitations of the Firebase Realtime Database, allowing for infinite datasets without performance degradation.
Deploying a Streaming XML Parser provides a robust ingestion pipeline for legacy ENEX data, managing memory efficiently through iterparse.
Bridging HTMX and Masonry via the htmx:afterSwap event listener resolves the geometry calculation conflicts, delivering the desired sophisticated UI without the fragility of a full SPA framework.
This architecture is not merely a rewrite; it is a simplification. It reduces the surface area for bugs (no hydration), lowers the barrier to entry for maintenance (standard Python/HTML), and creates a system that is resilient by design.
Works cited
Implementing HTMX with Flask and Jinja2 for Dynamic Content Rendering, accessed November 24, 2025, https://dev.to/hexshift/implementing-htmx-with-flask-and-jinja2-for-dynamic-content-rendering-2bck
Building a fullstack app with Flask and Htmx - Hacker News, accessed November 24, 2025, https://news.ycombinator.com/item?id=30843275
Masonry.js - David DeSandro, accessed November 24, 2025, https://masonry.desandro.com/
Re-initialize / layout Masonry after a sprig change - Craft CMS Stack Exchange, accessed November 24, 2025, https://craftcms.stackexchange.com/questions/38159/re-initialize-layout-masonry-after-a-sprig-change
enexlib - PyPI, accessed November 24, 2025, https://pypi.org/project/enexlib/
Source code for langchain_community.document_loaders.evernote - LangChain docs, accessed November 24, 2025, https://python.langchain.com/api_reference/_modules/langchain_community/document_loaders/evernote.html
Common folder/file structure in Flask app [closed] - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/14415500/common-folder-file-structure-in-flask-app
Firebase database CRUD sample with Python Flask web application - Absolute Code Works, accessed November 24, 2025, https://absolutecodeworks.com/firebase-database-crud-sample-with-python-flask-web-application
Make a Flask App with a NoSQL Database Using Firebase | by Kelly Lougheed | Medium, accessed November 24, 2025, https://kellylougheed.medium.com/make-a-flask-app-with-a-nosql-database-using-firebase-612972ca3c4
Structure Your Database - Firebase - Google, accessed November 24, 2025, https://firebase.google.com/docs/database/web/structure-data
Retrieving Data | Firebase Realtime Database - Google, accessed November 24, 2025, https://firebase.google.com/docs/database/admin/retrieve-data
Limiting a Firebase Realtime Database Query - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/60517856/limiting-a-firebase-realtime-database-query
Failing to implement pagination in Firebase realtime database - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/66075766/failing-to-implement-pagination-in-firebase-realtime-database
Firebase Real time database pagination - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/60870711/firebase-real-time-database-pagination
Parsing Evernote export file (.enex) using Python - GitHub Gist, accessed November 24, 2025, https://gist.github.com/foxmask/7b29c43a161e001ff04afdb2f181e31c
Evernote export format (ENEX) to HTML, including pictures? - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/1642104/evernote-export-format-enex-to-html-including-pictures
Passing HTML to template using Flask/Jinja2 - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/3206344/passing-html-to-template-using-flask-jinja2
14. Flask + Jinja — Programming for Financial Technology, accessed November 24, 2025, https://fintechpython.pages.oit.duke.edu/jupyternotebooks/7-WebDevelopment/14-flask-template.html
macros in flask jinja templates to reduce repetition - YouTube, accessed November 24, 2025, https://www.youtube.com/watch?v=oq0V3o1DB7M
CSS-only masonry layout - Stack Overflow, accessed November 24, 2025, https://stackoverflow.com/questions/44377343/css-only-masonry-layout
CSS Masonry & CSS Grid - CSS-Tricks, accessed November 24, 2025, https://css-tricks.com/css-masonry-css-grid/
htmx ~ Events, accessed November 24, 2025, https://htmx.org/events/
hx-on::after-swap not triggering : r/htmx - Reddit, accessed November 24, 2025, https://www.reddit.com/r/htmx/comments/1bhtnv7/hxonafterswap_not_triggering/
After Swap events called on elements which have a hx-swap set to none · Issue #3300 · bigskysoftware/htmx - GitHub, accessed November 24, 2025, https://github.com/bigskysoftware/htmx/issues/3300
Can someone give me a little guide to using Masonry JS in Vanilla JS? - Reddit, accessed November 24, 2025, https://www.reddit.com/r/Frontend/comments/16l7flv/can_someone_give_me_a_little_guide_to_using/
